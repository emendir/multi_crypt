In this library, a family of cryptographic algorithms is a collection of different sets of compounded algorithms for performing cryptographic operations that use intercompatible public & private keys because they share the same algorithm for the first layer in their cryptographic stacks.

## Functions:


_Use the code from ./crypto_family_template.py to get started on building your own module, it contains a few more useful details than this here._
Then, in `multi_crypt.py`, import the module and add it to the `crypto_modules` dictionary:
```python
from .algorithms import rsa, ec_secp256k1

crypto_modules = {"EC-secp256k1": ec_secp256k1, "RSA": rsa}
```

Each module must provide the following functions and a string `FAMILY_NAME`:
```python
FAMILY_NAME = ""

def generate_keys(keylength: int = None):
    """Generate a pair of public and private keys.
    Args:
        keylength (int): the number of bits the key is composed of
    Returns:
        tuple: tuple of bytess, a public key and a private key
    """
    private_key: bytes
    public_key: bytes
    return (public_key, private_key)


def check_key_pair(
    private_key: bytes,
    public_key: bytes
) -> bool:
    """Check if a private key and public key form a valid keypair.
    Args:
        private_key (bytes): the private key
        public_key (bytes): the public key
    Returns:
        bool: True if the keys form a valid pair, False otherwise
    """
    return True  # or False


def encrypt(
    data_to_encrypt: bytes,
    public_key: bytes,
    encryption_options: str = None
):
    """Encrypt the provided data using the specified public key.
    Args:
        data_to_encrypt (bytes): the data to encrypt
        public_key (bytes): the public key to be used for the encryption
        encryption_options (str): specification code for which
                                encryption/decryption protocol should be used
    Returns:
        bytes: the encrypted data
    """
    cipher: bytes
    return cipher


def decrypt(
    data_to_decrypt: bytes,
    private_key: bytes,
    encryption_options: str = None
):
    """Decrypt the provided data using the specified private key.
    Args:
        data_to_decrypt (bytes): the data to decrypt
        private_key (bytes): the private key to be used for the decryption
        encryption_options (str): specification code for which
                                encryption/decryption protocol should be used
    Returns:
        bytes: the decrypted data
    """
    plaintext: bytes
    return plaintext


def sign(
    data: bytes,
    private_key: bytes,
    signature_options: str = None
):
    """Sign the provided data using the specified private key.
    Args:
        data (bytes): the data to sign
        private_key (bytes): the private key to be used for the signing
        signature_options (str): specification code for which
                                signature/verification protocol should be used
    Returns:
        bytes: the signature
    """
    signature: bytes
    return signature


def verify_signature(
    family: str,
    signature: bytes,
    data: bytes,
    public_key: bytes,
    signature_options: str = None
):
    """Verify the provided signature of the provided data using the specified
    private key.
    Args:
        signature (bytes): the signaure to verify
        data (bytes): the data to sign
        public_key (bytes): the public key to verify the signature against
        signature_options (str): specification code for which
                                signature/verification protocol should be used
    Returns:
        bool: whether or not the signature matches the data
    """
    authenitcated: bool
    return authenitcated


def get_encrytpion_options():
    """Get the encryption options supported by this cryptographic family.
    Returns:
        list: a list of strings, the supported encryption options
    """
    encryption_options:list
    return encryption_options

def get_signature_options():
    """Get the signature options supported by this cryptographic family.
    Returns:
        list: a list of strings, the supported signature options
    """
    signature_options: list
    return signature_options
```

The functions that take keys as inputs must be able to process all possible keys generated by the family's generate_keys() function, independently of their configuration options.

## Optional Arguments
### Function `generate_keys`:
You can give `generate_keys` any keyword arguments that you want, or none.
The `keylength` argument is just used here as an example.
### Arguments `encryption_options` and `signature_options`:
You must implement these keyword arguments, because they manifest multi_crypt's concept of separating the user-relevant first-layer algorithms (cryptography families) from the various algorithms and protocols compounded on them for hybrid cryptography.
