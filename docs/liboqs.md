# liboqs Integration Design

## Overview

This document describes how quantum-safe algorithms from the `liboqs-python` library are integrated into MultiCrypt's family/options architecture.

## Background on liboqs

**liboqs** (Open Quantum Safe) provides Python bindings for post-quantum cryptographic algorithms standardized by NIST and other candidates. These algorithms are designed to resist attacks from both classical and quantum computers.

### Key Concepts

#### Key Encapsulation Mechanisms (KEM)
KEMs differ from traditional public-key encryption:
- **Traditional encryption**: Sender chooses a message and encrypts it
- **KEM**: Generates a random shared secret between sender and receiver

KEMs are used in **hybrid encryption** following the KEM/DEM (Key Encapsulation Mechanism / Data Encapsulation Mechanism) pattern (RFC 9180 - HPKE):
1. Sender uses recipient's public key to encapsulate a random symmetric key → produces (ciphertext, shared_secret)
2. Sender encrypts data with the shared_secret using symmetric encryption (e.g., AES-GCM)
3. Recipient decapsulates the ciphertext with their private key → recovers shared_secret
4. Recipient decrypts data with the shared_secret

This maintains **stateless asymmetric communication** - no session state required.

#### Signature Algorithms
Post-quantum signature schemes work similarly to classical signatures:
- `sign(message, private_key)` → signature
- `verify(message, signature, public_key)` → bool

### Fundamental Limitation: Separate Keypairs Required

Unlike classical cryptography (RSA, EC-secp256k1) where a single keypair can be used for both encryption and signing, **post-quantum algorithms fundamentally separate these operations**:

- **ML-KEM** (FIPS 203): Key encapsulation ONLY - cannot sign
- **ML-DSA** (FIPS 204): Digital signatures ONLY - cannot encrypt

This is not a library limitation but a mathematical reality - NIST standardized different algorithms optimized for different purposes.

## Family Architecture Decision

### The Challenge

MultiCrypt's "family" concept requires:
> Keys generated by a family's `generate_keys()` function work with all operations in that family

Post-quantum cryptography breaks this assumption since no single keypair supports both operations.

### Solution: Bundled Hybrid Families

Each MultiCrypt post-quantum family will be a **hybrid family** that bundles together:
- One KEM algorithm (for encryption/decryption)
- One signature algorithm (for sign/verify)

A single `generate_keys()` call generates **two separate keypairs** internally, bundled into single public/private key objects.

### Family Naming Convention

Format: `PQ-<KEM_VARIANT>-<SIG_VARIANT>`

**Standard families:**
- `PQ-ML-KEM-512-ML-DSA-44` - Lower security (AES-128 equivalent)
- `PQ-ML-KEM-768-ML-DSA-65` - Medium security (AES-192 equivalent) - **recommended default**
- `PQ-ML-KEM-1024-ML-DSA-87` - High security (AES-256 equivalent)

Additional families following standardization:
- `PQ-ML-KEM-768-Falcon-512` - ML-KEM with compact Falcon signatures
- `PQ-FrodoKEM-976-ML-DSA-65` - Conservative lattice KEM with ML-DSA
- etc.

## Key Encoding Strategy

### Fixed Key Sizes

All ML-KEM and ML-DSA algorithms use **fixed, deterministic key sizes**:

| Algorithm | Public Key | Private Key |
|-----------|------------|-------------|
| **ML-KEM-512** | 800 bytes | 1,632 bytes |
| **ML-KEM-768** | 1,184 bytes | 2,400 bytes |
| **ML-KEM-1024** | 1,568 bytes | 3,168 bytes |
| **ML-DSA-44** | 1,312 bytes | 2,560 bytes |
| **ML-DSA-65** | 1,952 bytes | 4,032 bytes |
| **ML-DSA-87** | 2,592 bytes | 4,896 bytes |

### Encoding Approach: Simple Concatenation

Since key sizes are fixed, we use **direct concatenation without separators**:

```python
# Bundle creation
public_key_bundle = kem_public_key + sig_public_key
private_key_bundle = kem_private_key + sig_private_key

# Bundle extraction (each family knows its algorithm sizes)
kem_pub = public_key_bundle[0:KEM_PUBLIC_SIZE]
sig_pub = public_key_bundle[KEM_PUBLIC_SIZE:]

kem_priv = private_key_bundle[0:KEM_PRIVATE_SIZE]
sig_priv = private_key_bundle[KEM_PRIVATE_SIZE:]
```

#### Example: PQ-ML-KEM-768-ML-DSA-65

**Public Key Bundle** (3,136 bytes total):
```
Bytes [0:1184]     → ML-KEM-768 public key (1,184 bytes)
Bytes [1184:3136]  → ML-DSA-65 public key (1,952 bytes)
```

**Private Key Bundle** (6,432 bytes total):
```
Bytes [0:2400]     → ML-KEM-768 private key (2,400 bytes)
Bytes [2400:6432]  → ML-DSA-65 private key (4,032 bytes)
```

### Advantages

1. **Zero overhead** - No separators, length prefixes, or encoding overhead
2. **Maximum efficiency** - Direct byte slicing
3. **Simple implementation** - No complex parsing logic
4. **Deterministic** - No ambiguity with fixed sizes
5. **Consistent with MultiCrypt** - Uses raw bytes like existing modules

## Operation Options

Within each family, **operation options** specify protocol details:

### Encryption Options

Control the symmetric cipher used in the KEM/DEM hybrid encryption:
- `AES-256-GCM` (default) - AES-256 in Galois/Counter Mode
- `ChaCha20-Poly1305` - ChaCha20 stream cipher with Poly1305 MAC
- `AES-128-GCM` - Lighter AES-128 variant

**Hybrid encryption workflow:**
1. `encap_secret(kem_public_key)` → (kem_ciphertext, shared_secret)
2. Encrypt data with AES-GCM using shared_secret as key → aes_ciphertext
3. Return: `kem_ciphertext || nonce || aes_ciphertext || tag`

Example: `PQ-ML-KEM-768-ML-DSA-65` family with `encryption_options="ChaCha20-Poly1305"`

### Signature Options

Control signature protocol details:
- `direct` (default) - Sign message directly
- `prehash-SHA256` - Hash message with SHA-256 before signing (for large messages)
- `prehash-SHA512` - Hash message with SHA-512 before signing

Example: `PQ-ML-KEM-768-ML-DSA-65` family with `signature_options="prehash-SHA256"`

## Implementation Details

### Key Generation

```python
def generate_keys():
    """Generate bundled KEM and signature keypairs."""
    # Generate KEM keypair
    with oqs.KeyEncapsulation("ML-KEM-768") as kem:
        kem_public = kem.generate_keypair()
        kem_private = kem.export_secret_key()

    # Generate signature keypair
    with oqs.Signature("ML-DSA-65") as signer:
        sig_public = signer.generate_keypair()
        sig_private = signer.export_secret_key()

    # Bundle keys
    public_key = kem_public + sig_public
    private_key = kem_private + sig_private

    return (public_key, private_key)
```


**Note:** Implementation may require algorithm-specific logic or storing public key within private key bundle if liboqs doesn't support extraction. This needs verification during implementation.

### Encryption (KEM/DEM Hybrid)

```python
def encrypt(data, public_key_bundle, encryption_options="AES-256-GCM"):
    """Encrypt using KEM + symmetric cipher hybrid."""
    # Extract KEM public key
    kem_public = public_key_bundle[0:KEM_PUBLIC_SIZE]

    # Encapsulate to get shared secret
    with oqs.KeyEncapsulation("ML-KEM-768") as kem:
        kem_ciphertext, shared_secret = kem.encap_secret(kem_public)

    # Encrypt data with shared secret
    if encryption_options == "AES-256-GCM":
        cipher = AES.new(shared_secret[:32], AES.MODE_GCM)
        aes_ciphertext, tag = cipher.encrypt_and_digest(data)

        # Return: kem_ciphertext || nonce || aes_ciphertext || tag
        return kem_ciphertext + cipher.nonce + aes_ciphertext + tag
```

### Decryption

```python
def decrypt(ciphertext, private_key_bundle, encryption_options="AES-256-GCM"):
    """Decrypt using KEM + symmetric cipher hybrid."""
    # Extract KEM private key
    kem_private = private_key_bundle[0:KEM_PRIVATE_SIZE]

    # Parse ciphertext components
    kem_ciphertext = ciphertext[0:KEM_CIPHERTEXT_SIZE]
    nonce = ciphertext[KEM_CIPHERTEXT_SIZE:KEM_CIPHERTEXT_SIZE+16]
    aes_ciphertext = ciphertext[KEM_CIPHERTEXT_SIZE+16:-16]
    tag = ciphertext[-16:]

    # Decapsulate to recover shared secret
    with oqs.KeyEncapsulation("ML-KEM-768") as kem:
        kem.generate_keypair()  # Initialize
        # Import private key (may need special handling)
        shared_secret = kem.decap_secret(kem_ciphertext)

    # Decrypt data with shared secret
    if encryption_options == "AES-256-GCM":
        cipher = AES.new(shared_secret[:32], AES.MODE_GCM, nonce=nonce)
        return cipher.decrypt_and_verify(aes_ciphertext, tag)
```

### Signing

```python
def sign(data, private_key_bundle, signature_options="direct"):
    """Sign data using signature private key."""
    # Extract signature private key
    sig_private = private_key_bundle[KEM_PRIVATE_SIZE:]

    # Prepare data
    if signature_options == "prehash-SHA256":
        data = hashlib.sha256(data).digest()

    # Sign
    with oqs.Signature("ML-DSA-65") as signer:
        signer.generate_keypair()  # Initialize
        # Import private key and sign
        return signer.sign(data)
```

### Signature Verification

```python
def verify_signature(signature, data, public_key_bundle, signature_options="direct"):
    """Verify signature using signature public key."""
    # Extract signature public key
    sig_public = public_key_bundle[KEM_PUBLIC_SIZE:]

    # Prepare data
    if signature_options == "prehash-SHA256":
        data = hashlib.sha256(data).digest()

    # Verify
    with oqs.Signature("ML-DSA-65") as verifier:
        return verifier.verify(data, signature, sig_public)
```

## Module Structure

### Approach 1: Individual Family Modules (Initial)

```
multi_crypt/algorithms/
├── pq_ml_kem_512_ml_dsa_44.py
├── pq_ml_kem_768_ml_dsa_65.py
└── pq_ml_kem_1024_ml_dsa_87.py
```

Each module is self-contained with hardcoded constants.

### Approach 2: Template/Factory Pattern (Future)

```
multi_crypt/algorithms/
├── pq_hybrid_base.py          # Base template
└── pq_families.py             # Configuration + factory
```

Use a template to reduce duplication across security levels.

## Implementation Priority

### Phase 1: Core Implementation (Priority)
1. **PQ-ML-KEM-768-ML-DSA-65** - Standard security level, most common

### Phase 2: Alternative Security Levels
2. **PQ-ML-KEM-512-ML-DSA-44** - Lower security, faster
3. **PQ-ML-KEM-1024-ML-DSA-87** - Higher security, larger keys

### Phase 3: Alternative Algorithms (Lower Priority)
4. **PQ-ML-KEM-768-Falcon-512** - Compact signatures
5. **PQ-FrodoKEM-976-ML-DSA-65** - Conservative KEM choice

## Dependencies

```
liboqs-python>=0.11.0
pycryptodome>=3.20.0  # For AES-GCM symmetric encryption
```

**System requirement:** liboqs C library must be installed system-wide.

Installation:
```bash
# Ubuntu/Debian
sudo apt-get install liboqs-dev

# pip install
pip install liboqs-python pycryptodome
```

## Algorithm-Specific Constants

### ML-KEM Ciphertext Sizes

| Algorithm | Ciphertext Size |
|-----------|-----------------|
| ML-KEM-512 | 768 bytes |
| ML-KEM-768 | 1,088 bytes |
| ML-KEM-1024 | 1,568 bytes |

### ML-DSA Signature Sizes

| Algorithm | Signature Size (max) |
|-----------|---------------------|
| ML-DSA-44 | 2,420 bytes |
| ML-DSA-65 | 3,309 bytes |
| ML-DSA-87 | 4,627 bytes |

Note: ML-DSA signatures have variable length but bounded by these maximums.

## Testing Strategy

1. **Key generation and derivation**
   - Verify bundled keys are correct length
   - Test derive_public_key() reconstructs correct public keys
   - Verify KEM and signature components are independently valid

2. **Encryption/decryption round-trip**
   - Test all encryption_options
   - Verify stateless operation (no session state)
   - Test with various data sizes

3. **Signature/verification**
   - Test all signature_options
   - Verify correct signatures validate
   - Verify tampered signatures/data fail

4. **Key compatibility**
   - Verify keys from one family cannot be used with another family
   - Verify different security levels are incompatible

5. **Interoperability**
   - Test against liboqs reference implementations
   - Verify compatibility with other liboqs-based tools

6. **Edge cases**
   - Empty data
   - Large data (>1MB)
   - Invalid keys
   - Corrupted ciphertexts/signatures

## Security Considerations

1. **Algorithm selection**: ML-KEM and ML-DSA are NIST-standardized (2024)
2. **Security levels**: Choose appropriate level for use case
   - Level 1 (512/44): Fast, suitable for short-term security
   - Level 3 (768/65): Balanced, recommended for most use cases
   - Level 5 (1024/87): Maximum security, larger overhead
3. **Hybrid cryptography**: Consider combining with classical algorithms for defense-in-depth
4. **Key storage**: Bundled private keys are ~6-8KB and contain sensitive material
5. **Side-channel resistance**: liboqs aims for constant-time operations
6. **Ciphertext/signature overhead**: Post-quantum outputs are significantly larger than classical

## Comparison with Classical Algorithms

| Metric | RSA-2048 | EC-secp256k1 | PQ-ML-KEM-768-ML-DSA-65 |
|--------|----------|--------------|-------------------------|
| Public key | 294 bytes | 65 bytes | 3,136 bytes |
| Private key | 1,192 bytes | 32 bytes | 6,432 bytes |
| Ciphertext overhead | +256 bytes | ~113 bytes | +1,088 bytes (KEM) + 16-32 (AES) |
| Signature size | 256 bytes | ~71 bytes | ~3,309 bytes |
| Quantum-safe | ❌ No | ❌ No | ✅ Yes |

## References

- [Open Quantum Safe](https://openquantumsafe.org/)
- [liboqs GitHub](https://github.com/open-quantum-safe/liboqs)
- [liboqs-python GitHub](https://github.com/open-quantum-safe/liboqs-python)
- [RFC 9180 - HPKE](https://datatracker.ietf.org/doc/html/rfc9180)
- [NIST FIPS 203 - ML-KEM](https://csrc.nist.gov/pubs/fips/203/final)
- [NIST FIPS 204 - ML-DSA](https://csrc.nist.gov/pubs/fips/204/final)
- [NIST Post-Quantum Cryptography](https://csrc.nist.gov/projects/post-quantum-cryptography)
